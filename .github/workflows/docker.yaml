name: Docker

on:
  workflow_dispatch:
  push:
    branches: [ main ]

env:
  ALIYUN_REGISTRY: "${{ secrets.ALIYUN_REGISTRY }}"
  ALIYUN_NAME_SPACE: "${{ secrets.ALIYUN_NAME_SPACE }}"
  ALIYUN_REGISTRY_USER: "${{ secrets.ALIYUN_REGISTRY_USER }}"
  ALIYUN_REGISTRY_PASSWORD: "${{ secrets.ALIYUN_REGISTRY_PASSWORD }}"

jobs:
  # 第一步：将镜像列表分批
  prepare:
    name: Prepare Batches
    runs-on: ubuntu-latest
    outputs:
      batches: ${{ steps.create-batches.outputs.batches }}
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
    
    - name: Create Batches
      id: create-batches
      run: |
        # 每批处理的镜像数量（可调整）
        BATCH_SIZE=50
        
        # 读取并清理镜像列表
        mapfile -t images < <(grep -v '^\s*#' images.txt | grep -v '^\s*$')
        
        # 分批
        batches="["
        batch_num=0
        for ((i=0; i<${#images[@]}; i+=BATCH_SIZE)); do
          if [ $batch_num -gt 0 ]; then
            batches+=","
          fi
          batches+="{\"id\":$batch_num,\"start\":$i,\"size\":$BATCH_SIZE}"
          ((batch_num++))
        done
        batches+="]"
        
        echo "batches=$batches" >> $GITHUB_OUTPUT
        echo "Total batches: $batch_num"

  # 第二步：并发处理每个批次
  build:
    name: Batch ${{ matrix.batch.id }}
    needs: prepare
    runs-on: ubuntu-latest
    strategy:
      max-parallel: 5  # 同时运行5个批次
      fail-fast: false
      matrix:
        batch: ${{ fromJson(needs.prepare.outputs.batches) }}
    
    steps:
    - name: Before freeing up disk space
      run: |
        echo "Before freeing up disk space"
        echo "=============================================================================="
        df -hT
        echo "=============================================================================="

    - name: Maximize build space
      uses: easimon/maximize-build-space@master
      with:
        root-reserve-mb: 2048
        swap-size-mb: 128
        remove-dotnet: 'true'
        remove-haskell: 'true'
        remove-android: 'true'
        remove-codeql: 'true'
        build-mount-path: '/var/lib/docker/'

    - name: Restart docker
      run: sudo service docker restart

    - name: Free up disk space complete
      run: |
        echo "Free up disk space complete"
        echo "=============================================================================="
        df -hT
        echo "=============================================================================="

    - name: Checkout Code
      uses: actions/checkout@v4

    - name: Docker Setup Buildx
      uses: docker/setup-buildx-action@v3

    - name: Clean up before processing
      run: |
        # 清理 apt 缓存
        sudo apt-get clean
        sudo rm -rf /var/lib/apt/lists/*
        
        # 清理 Docker 缓存和悬空镜像
        docker system prune -af --volumes
        
        echo "Disk space after cleanup:"
        df -h
    
    - name: Process Batch
      run: |
        docker login -u $ALIYUN_REGISTRY_USER -p $ALIYUN_REGISTRY_PASSWORD $ALIYUN_REGISTRY
        
        BATCH_START=${{ matrix.batch.start }}
        BATCH_SIZE=${{ matrix.batch.size }}
        
        # 数据预处理：检测重复镜像名
        declare -A duplicate_images
        declare -A temp_map
        while IFS= read -r line || [ -n "$line" ]; do
            [[ -z "$line" ]] && continue
            if echo "$line" | grep -q '^\s*#'; then
                continue
            fi
            
            image=$(echo "$line" | awk '{print $NF}')
            image="${image%%@*}"
            image_name_tag=$(echo "$image" | awk -F'/' '{print $NF}')
            name_space=$(echo "$image" | awk -F'/' '{if (NF==3) print $2; else if (NF==2) print $1; else print ""}')
            name_space="${name_space}_"
            image_name=$(echo "$image_name_tag" | awk -F':' '{print $1}')
            
            if [[ -n "${temp_map[$image_name]}" ]]; then
                 if [[ "${temp_map[$image_name]}" != $name_space  ]]; then
                    duplicate_images[$image_name]="true"
                 fi
            else
                temp_map[$image_name]=$name_space
            fi       
        done < images.txt
        
        # 处理当前批次
        current=0
        while IFS= read -r line || [ -n "$line" ]; do
            [[ -z "$line" ]] && continue
            if echo "$line" | grep -q '^\s*#'; then
                continue
            fi
            
            # 跳过不属于当前批次的镜像
            if [ $current -lt $BATCH_START ]; then
                ((current++))
                continue
            fi
            
            if [ $current -ge $((BATCH_START + BATCH_SIZE)) ]; then
                break
            fi
            
            echo "=========================================="
            echo "Processing image $current: $line"
            echo "=========================================="
            
            # 拉取前检查磁盘空间
            available=$(df /var/lib/docker | tail -1 | awk '{print $4}')
            if [ "$available" -lt 5242880 ]; then  # 小于 5GB
                echo "WARNING: Low disk space, running cleanup..."
                docker system prune -af
            fi
            
            docker pull $line
            
            platform=$(echo "$line" | awk -F'--platform[ =]' '{if (NF>1) print $2}' | awk '{print $1}')
            if [ -z "$platform" ]; then
                platform_prefix=""
            else
                platform_prefix="${platform//\//_}_"
            fi
            
            image=$(echo "$line" | awk '{print $NF}')
            image_name_tag=$(echo "$image" | awk -F'/' '{print $NF}')
            name_space=$(echo "$image" | awk -F'/' '{if (NF==3) print $2; else if (NF==2) print $1; else print ""}')
            image_name=$(echo "$image_name_tag" | awk -F':' '{print $1}')
        
            name_space_prefix=""
            if [[ -n "${duplicate_images[$image_name]}" ]]; then
               if [[ -n "${name_space}" ]]; then
                  name_space_prefix="${name_space}_"
               fi
            fi
            
            image_name_tag="${image_name_tag%%@*}"
            new_image="$ALIYUN_REGISTRY/$ALIYUN_NAME_SPACE/$platform_prefix$name_space_prefix$image_name_tag"
            
            docker tag $image $new_image
            docker push $new_image
            
            # 立即清理以释放空间 - 强制删除
            docker rmi -f $image 2>/dev/null || true
            docker rmi -f $new_image 2>/dev/null || true
            
            # 每处理完5个镜像就做一次深度清理
            if [ $((current % 5)) -eq 0 ]; then
                echo "Deep cleaning at image $current..."
                docker system prune -af --volumes
                df -h | grep -E '(Filesystem|/dev/root|docker)'
            fi
            
            ((current++))
        done < images.txt
        
        echo "=============================================================================="
        echo "Batch ${{ matrix.batch.id }} completed. Processed images: $BATCH_START to $((current-1))"
        df -hT
        echo "=============================================================================="
